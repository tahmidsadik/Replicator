;; Analyzed by ClojureScript 0.0-3464
{:use-macros nil, :excludes #{}, :name clojure.walk, :imports nil, :requires nil, :uses nil, :defs {walk {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 37, :column 7, :end-line 37, :end-column 11, :arglists (quote ([inner outer form])), :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :added "1.1"}, :added "1.1", :name clojure.walk/walk, :variadic false, :file "out/clojure/walk.cljs", :end-column 11, :method-params ([inner outer form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 37, :max-fixed-arity 3, :fn-var true, :arglists (quote ([inner outer form])), :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."}, postwalk {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 54, :column 7, :end-line 54, :end-column 15, :arglists (quote ([f form])), :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :added "1.1"}, :added "1.1", :name clojure.walk/postwalk, :variadic false, :file "out/clojure/walk.cljs", :end-column 15, :method-params ([f form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 54, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f form])), :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."}, prewalk {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 62, :column 7, :end-line 62, :end-column 14, :arglists (quote ([f form])), :doc "Like postwalk, but does pre-order traversal.", :added "1.1"}, :added "1.1", :name clojure.walk/prewalk, :variadic false, :file "out/clojure/walk.cljs", :end-column 14, :method-params ([f form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 62, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f form])), :doc "Like postwalk, but does pre-order traversal."}, keywordize-keys {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 68, :column 7, :end-line 68, :end-column 22, :arglists (quote ([m])), :doc "Recursively transforms all map keys from strings to keywords.", :added "1.1"}, :added "1.1", :name clojure.walk/keywordize-keys, :variadic false, :file "out/clojure/walk.cljs", :end-column 22, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 68, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Recursively transforms all map keys from strings to keywords."}, stringify-keys {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 76, :column 7, :end-line 76, :end-column 21, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings.", :added "1.1"}, :added "1.1", :name clojure.walk/stringify-keys, :variadic false, :file "out/clojure/walk.cljs", :end-column 21, :method-params ([m]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 76, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m])), :doc "Recursively transforms all map keys from keywords to strings."}, prewalk-replace {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 84, :column 7, :end-line 84, :end-column 22, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :added "1.1"}, :added "1.1", :name clojure.walk/prewalk-replace, :variadic false, :file "out/clojure/walk.cljs", :end-column 22, :method-params ([smap form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 84, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first."}, postwalk-replace {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/walk.cljs", :line 92, :column 7, :end-line 92, :end-column 23, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :added "1.1"}, :added "1.1", :name clojure.walk/postwalk-replace, :variadic false, :file "out/clojure/walk.cljs", :end-column 23, :method-params ([smap form]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 92, :max-fixed-arity 2, :fn-var true, :arglists (quote ([smap form])), :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first."}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."}