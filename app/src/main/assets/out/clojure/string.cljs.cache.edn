;; Analyzed by ClojureScript 0.0-3464
{:use-macros nil, :excludes #{reverse replace}, :name clojure.string, :imports {StringBuffer goog.string.StringBuffer}, :requires {gstring goog.string, goog.string goog.string, StringBuffer goog.string.StringBuffer}, :uses nil, :defs {seq-reverse {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 14, :column 8, :end-line 14, :end-column 19, :private true, :arglists (quote ([coll]))}, :private true, :name clojure.string/seq-reverse, :variadic false, :file "out/clojure/string.cljs", :end-column 19, :method-params ([coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 14, :max-fixed-arity 1, :fn-var true, :arglists (quote ([coll]))}, capitalize {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 78, :column 7, :end-line 78, :end-column 17, :arglists (quote ([s])), :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case."}, :name clojure.string/capitalize, :variadic false, :file "out/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case."}, reverse {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 21, :column 7, :end-line 21, :end-column 14, :arglists (quote ([s])), :doc "Returns s with its characters reversed."}, :name clojure.string/reverse, :variadic false, :file "out/clojure/string.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 21, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns s with its characters reversed."}, join {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 49, :column 7, :end-line 49, :end-column 11, :arglists (quote ([coll] [separator coll])), :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [separator coll]), :arglists ([coll] [separator coll]), :arglists-meta (nil nil)}}, :name clojure.string/join, :variadic false, :file "out/clojure/string.cljs", :end-column 11, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([coll] [separator coll]), :arglists ([coll] [separator coll]), :arglists-meta (nil nil)}, :method-params ([coll] [separator coll]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 49, :max-fixed-arity 2, :fn-var true, :arglists ([coll] [separator coll]), :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator."}, replace-first {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 40, :column 7, :end-line 40, :end-column 20, :arglists (quote ([s match replacement])), :doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match)."}, :name clojure.string/replace-first, :variadic false, :file "out/clojure/string.cljs", :end-column 20, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 40, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces the first instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match)."}, escape {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 179, :column 7, :end-line 179, :end-column 13, :arglists (quote ([s cmap])), :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead."}, :name clojure.string/escape, :variadic false, :file "out/clojure/string.cljs", :end-column 13, :method-params ([s cmap]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 179, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s cmap])), :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead."}, discard-trailing-if-needed {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 103, :column 8, :end-line 103, :end-column 34, :private true, :arglists (quote ([limit v]))}, :private true, :name clojure.string/discard-trailing-if-needed, :variadic false, :file "out/clojure/string.cljs", :end-column 34, :method-params ([limit v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 103, :max-fixed-arity 2, :fn-var true, :arglists (quote ([limit v]))}, pop-last-while-empty {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 96, :column 8, :end-line 96, :end-column 28, :private true, :arglists (quote ([v]))}, :private true, :name clojure.string/pop-last-while-empty, :variadic false, :file "out/clojure/string.cljs", :end-column 28, :method-params ([v]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 96, :max-fixed-arity 1, :fn-var true, :arglists (quote ([v]))}, replace {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 27, :column 7, :end-line 27, :end-column 14, :arglists (quote ([s match replacement])), :doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match)."}, :name clojure.string/replace, :variadic false, :file "out/clojure/string.cljs", :end-column 14, :method-params ([s match replacement]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 27, :max-fixed-arity 3, :fn-var true, :arglists (quote ([s match replacement])), :doc "Replaces all instance of match with replacement in s.\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match)."}, split-lines {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 142, :column 7, :end-line 142, :end-column 18, :arglists (quote ([s])), :doc "Splits s on \n or \r\n."}, :name clojure.string/split-lines, :variadic false, :file "out/clojure/string.cljs", :end-column 18, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 142, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Splits s on \n or \r\n."}, lower-case {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 73, :column 7, :end-line 73, :end-column 17, :arglists (quote ([s])), :doc "Converts string to all lower-case."}, :name clojure.string/lower-case, :variadic false, :file "out/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 73, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all lower-case."}, trim-newline {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 162, :column 7, :end-line 162, :end-column 19, :arglists (quote ([s])), :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp."}, :name clojure.string/trim-newline, :variadic false, :file "out/clojure/string.cljs", :end-column 19, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 162, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp."}, upper-case {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 68, :column 7, :end-line 68, :end-column 17, :arglists (quote ([s])), :doc "Converts string to all upper-case."}, :name clojure.string/upper-case, :variadic false, :file "out/clojure/string.cljs", :end-column 17, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 68, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Converts string to all upper-case."}, split {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 119, :column 7, :end-line 119, :end-column 12, :arglists (quote ([s re] [s re limit])), :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits.", :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s re] [s re limit]), :arglists ([s re] [s re limit]), :arglists-meta (nil nil)}}, :name clojure.string/split, :variadic false, :file "out/clojure/string.cljs", :end-column 12, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([s re] [s re limit]), :arglists ([s re] [s re limit]), :arglists-meta (nil nil)}, :method-params ([s re] [s re limit]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 119, :max-fixed-arity 3, :fn-var true, :arglists ([s re] [s re limit]), :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of splits. Not lazy. Returns vector of the splits."}, trimr {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 157, :column 7, :end-line 157, :end-column 12, :arglists (quote ([s])), :doc "Removes whitespace from the right side of string."}, :name clojure.string/trimr, :variadic false, :file "out/clojure/string.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 157, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the right side of string."}, trim {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 147, :column 7, :end-line 147, :end-column 11, :arglists (quote ([s])), :doc "Removes whitespace from both ends of string."}, :name clojure.string/trim, :variadic false, :file "out/clojure/string.cljs", :end-column 11, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 147, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from both ends of string."}, triml {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 152, :column 7, :end-line 152, :end-column 12, :arglists (quote ([s])), :doc "Removes whitespace from the left side of string."}, :name clojure.string/triml, :variadic false, :file "out/clojure/string.cljs", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 152, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Removes whitespace from the left side of string."}, blank? {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 174, :column 7, :end-line 174, :end-column 13, :arglists (quote ([s])), :doc "True is s is nil, empty, or contains only whitespace."}, :name clojure.string/blank?, :variadic false, :file "out/clojure/string.cljs", :end-column 13, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "True is s is nil, empty, or contains only whitespace."}, re-surrogate-pair {:name clojure.string/re-surrogate-pair, :file "out/clojure/string.cljs", :line nil, :column nil, :end-line 18, :end-column 33, :private true, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 18, :column 16, :end-line 18, :end-column 33, :private true}}, split-with-empty-regex {:protocol-inline nil, :meta {:file "/Users/tahmid/code/clojure/replete/ClojureScript/replete/out/clojure/string.cljs", :line 109, :column 8, :end-line 109, :end-column 30, :private true, :arglists (quote ([s limit]))}, :private true, :name clojure.string/split-with-empty-regex, :variadic false, :file "out/clojure/string.cljs", :end-column 30, :method-params ([s limit]), :protocol-impl nil, :arglists-meta (nil nil), :column nil, :line nil, :end-line 109, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s limit]))}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else}, :order [:else]}, :doc nil}